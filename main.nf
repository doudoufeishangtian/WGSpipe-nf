#!/usr/bin/env nextflow
/*
================================================================================
--------------------------------------------------------------------------------
			NEXTFLOW pipeline for WGS/WES analysis
			provided by @zhangdongqin2@126.com 
--------------------------------------------------------------------------------
================================================================================
WGS/WES pipeline is a quick and easy pipeline deploy on linux/Mac system.
This pipeline is supported run on specified conda environment.
You can use environment.yml to create a conda environment for this pipeline.
You can run this pipeline on local conda env by < -with-conda /path/to/conda/env >
This pipeline is desiged and implement by Zhang.DQ < zhangdongqin2@126.com >
Pipeline visualization is supported by nf-core
================================================================================
*/
ANSI_RESET = "\u001B[0m";
ANSI_BLACK = "\u001B[30m";
ANSI_RED = "\u001B[31m";
ANSI_GREEN = "\u001B[32m";
ANSI_YELLOW = "\u001B[33m";
ANSI_BLUE = "\u001B[34m";
ANSI_PURPLE = "\u001B[35m";
ANSI_CYAN = "\u001B[36m";
ANSI_WHITE = "\u001B[37m";
def print_red = {  str -> ANSI_RED + str + ANSI_RESET }
def print_black = {  str -> ANSI_BLACK + str + ANSI_RESET }
def print_green = {  str -> ANSI_GREEN + str + ANSI_RESET }
def print_yellow = {  str -> ANSI_YELLOW + str + ANSI_RESET }
def print_blue = {  str -> ANSI_BLUE + str + ANSI_RESET }
def print_cyan = {  str -> ANSI_CYAN + str + ANSI_RESET }
def print_purple = {  str -> ANSI_PURPLE + str + ANSI_RESET }
def print_white = {  str -> ANSI_WHITE + str + ANSI_RESET }

nextflow.enable.dsl = 2

def helpMessage() {
    log.info nfcoreHeader()
    log.info"""
    A Nextflow-based RNAseq Analysis Pipeline,version:$params.version
    Usage:

    The typical command for running the pipeline is as follows:

    nextflow run main.nf --genome genome.fa --reference /path/to/snpindel_annotation --reads 'reads/*_{1,2}.fq.gz'

    PSï¼š /path/to/snpindel_annotation is defined as a standard google cloud database directory for WGS/WES
    Annotation can be download in < https://console.cloud.google.com/storage/browser/genomics-public-data/resources/broad/hg38/v0;tab=objects?pageState=(%22StorageObjectListTable%22:(%22f%22:%22%255B%255D%22))&prefix=&forceOnObjectsSortingFiltering=false >
    Required arguments:
      --reads        [file]           Path to input data (must be surrounded with quotes) < 'reads/*_{1,2}.fq.gz' >
      --genome       [file]           Path to reference genome fasta file < /home/db/genome.fa >
      --reference    [path]           Path to genome snp/indel annotation directory from google cloud          

    Optional arguments:
      --bwa_index    [path]           Path to bwa index for bwa mapping. Default is false, program will denovo generate bwa index.
      --help          [str]           Help information for wgs/wes pipeline
      --cpus          [int]           Cpu cores for pipeline , default is 6, you can specify core numbers with < --cpu 8 >
      --outdir       [path]           Path to analysis results directory ,defalut is < ./results >.
      --single_end   [bool]           Specifies that the input is single-end reads
      --annovar      [bool]           Specifies that whether annovar is used in this pipeline
    Other Options:
      --debug        [bool]           Flag to run only specific fusion tool/s and not the whole pipeline. Only works on tool flags.
      --outdir       [file]           The output directory where the results will be saved
      --email       [email]           Set this parameter to your e-mail address to get a summary e-mail with details of the run sent to you when the workflow exits
      --email_on_fail[email]          Same as --email, except only send mail if the workflow is not successful
      --max_multiqc_email_size [str]  Theshold size for MultiQC report to be attached in notification email. If file generated by pipeline exceeds the threshold, it will not be attached (Default: 25MB)
      -name [str]                     Name for the pipeline run. If not specified, Nextflow will automatically generate a random mnemonic

    AWSBatch options:
      --awsqueue [str]                The AWSBatch JobQueue that needs to be set when running on AWSBatch
      --awsregion [str]               The AWS Region for your AWS Batch job to run on
      --awscli [str]                  Path to the AWS CLI tool
    """.stripIndent()
}


if (params.help) exit 0, helpMessage()	
if ( params.genome )        {      genome_fasta = file(params.genome)   } else { exit 1, 'ERROR:Genome fasta file not specified!' }
if (params.reads){ raw_reads = Channel.fromFilePairs(params.reads,size: params.single_end ? 1 : 2 )
										 .ifEmpty{ exit 1, "ERROR:Cannot find any reads matching: ${params.reads}\nNB: Path needs to be enclosed in quotes!" }
				   reads_fastp  = Channel.fromFilePairs(params.reads,size: params.single_end ? 1 : 2 )
}

if (params.reference) { 

  dbsnp        = file( params.dbsnp )
  indel1       = file( params.indel1 )
  indel2       = file( params.indel2 )
  hapmap       = file( params.hapmap )
  phase        = file( params.phase )
  omni         = file( params.omni )
  dbsnp_index  = file( params.dbsnp_index )
  indel1_index = file( params.indel1_index )
  indel2_index = file( params.indel2_index )
  hapmap_index = file( params.hapmap_index )
  phase_index  = file( params.phase_index )
  omni_index   = file( params.omni_index )

 }  else { exit 1, 'ERROR: Goole cloud reference directory for GATK variants calling is not specified' }


/*
if (params.reference) {
    dbsnp     = "${params.reference}/resources_broad_hg38_v0_Homo_sapiens_assembly38.dbsnp138.vcf"
    indel1    = "${params.reference}/resources_broad_hg38_v0_Homo_sapiens_assembly38.known_indels.vcf.gz"
    indel2    = "${params.reference}/resources_broad_hg38_v0_Mills_and_1000G_gold_standard.indels.hg38.vcf.gz"
    hapmap    = "${params.reference}/resources_broad_hg38_v0_hapmap_3.3.hg38.vcf.gz"
    phase     = "${params.reference}/resources_broad_hg38_v0_1000G_phase1.snps.high_confidence.hg38.vcf.gz"
    omni      = "${params.reference}/resources_broad_hg38_v0_1000G_omni2.5.hg38.vcf.gz"
    dbsnp_index  = "${params.reference}/resources_broad_hg38_v0_Homo_sapiens_assembly38.dbsnp138.vcf.idx"
    indel1_index = "${params.reference}/resources_broad_hg38_v0_Homo_sapiens_assembly38.known_indels.vcf.gz.tbi"
    indel2_index = "${params.reference}/resources_broad_hg38_v0_Mills_and_1000G_gold_standard.indels.hg38.vcf.gz.tbi"
    hapmap_index = "${params.reference}/resources_broad_hg38_v0_hapmap_3.3.hg38.vcf.gz.tbi"
    phase_index  = "${params.reference}/resources_broad_hg38_v0_1000G_phase1.snps.high_confidence.hg38.vcf.gz.tbi"
    omni_index   = "${params.reference}/resources_broad_hg38_v0_1000G_omni2.5.hg38.vcf.gz.tbi"
} else { exit 1, 'ERROR: Goole cloud reference directory for GATK variants calling is not specified' }

*/

log.info nfcoreHeader()
log.info print_yellow("=====================================")
log.info print_yellow("Fastq file extension:            ") + print_green(params.reads)
log.info print_yellow("Output directory:                ") + print_green(params.outdir)
log.info print_yellow("Genome sequence file:            ") + print_green(params.genome)
log.info print_yellow("BWA index path:                  ") + print_green(params.bwa_index)
log.info print_yellow("SNP/INDEL path:   	              ") + print_green(params.reference)
log.info print_yellow("Cpu core number:                 ") + print_green(params.cpus)
log.info print_yellow("DBSNP_annotation:                ") + print_green(dbsnp)
log.info print_yellow("Known_indels:                    ") + print_green(indel1)
log.info print_yellow("1000G_gold_standard.indels:      ") + print_green(indel2)
log.info print_yellow("HAPMAP_annotation:               ") + print_green(hapmap)
log.info print_yellow("1000G_phase1_annotation:         ") + print_green(phase)
log.info print_yellow("1000G_omni_annotation:           ") + print_green(omni)
log.info print_yellow("DBSNP_annotation_index:          ") + print_green(dbsnp_index)
log.info print_yellow("Known_indels_index:              ") + print_green(indel1_index)
log.info print_yellow("1000G_gold_standard.indels_index:") + print_green(indel2_index)
log.info print_yellow("HAPMAP_annotation_index:         ") + print_green(hapmap_index)
log.info print_yellow("1000G_phase1_annotation_index:   ") + print_green(phase_index)
log.info print_yellow("1000G_omni_annotation_index:     ") + print_green(omni_index)
log.info print_yellow("=====================================")

process GET_NEXTFLOW_SOFTWARE_VERSION_FOR_WGS_ANALYSIS {
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   echo $workflow.manifest.version > v_pipeline.txt
   echo $workflow.nextflow.version > v_nextflow.txt
   """
}
process GET_FASTQC_SOFTWARE_VERSION_FOR_WGS_ANALYSIS {
   label 'fastqc'
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   fastqc --version > v_fastqc.txt
   """
}
process GET_SAMTOOLS_SOFTWARE_VERSION_FOR_WGS_ANALYSIS {
   label 'samtools'
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   samtools --version > v_samtools.txt
   """
}
process GET_MULTIQC_SOFTWARE_VERSION_FOR_WGS_ANALYSIS {
   label 'multiqc'
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   multiqc --version > v_multiqc.txt
   """
}
process GET_BWA_SOFTWARE_VERSION_FOR_WGS_ANALYSIS {
   label 'bwa'
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
  echo \$(bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\$//' > v_bwa.txt
   """
}

process GET_GATK_SOFTWARE_VERSION_FOR_WGS_ANALYSIS{
    label 'gatk'
    publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

    output:
    path ("*.txt"), emit: software_version
    script:
    """
    gatk --version > v_gatk.txt
    """
}

process GET_FASTP_SOFTWARE_VERSION_FOR_WGS_ANALYSIS{
    label 'gatk'
    publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

    output:
    path ("*.txt"), emit: software_version
    script:
    """
    fastp --version > v_fastp.txt
    """
}


/*
--------------------------------------------------------------------------------
Define a fastqc for raw_reads function for pipeline
--------------------------------------------------------------------------------
*/

process FASTQC_QUALITY_CHECK_FOR_RAW_READS {
    tag "$sample"
    publishDir "${params.outdir}/raw_fastqc_report", mode: 'copy'
    input:
    tuple val(sample), path (reads)
    output:
    tuple val(sample), path("*.html"), emit: html
    tuple val(sample), path("*.zip") , emit: zip
    script:
    if (params.single_end) {
        """
        fastqc --threads $task.cpus ${reads}       
        """
    } else {
        """
        fastqc --threads $task.cpus ${reads[0]} ${reads[1]}
        """
}
}
/*
--------------------------------------------------------------------------------
Define a fastp for raw_reads function for pipeline
--------------------------------------------------------------------------------
*/
process FASTP_READS_FILTER_FOR_RAW_READS {
    tag "$sample"
    publishDir "${params.outdir}/fastp_report", mode: 'copy'
    input:
    tuple val(sample), path(reads)
    output:
    tuple val(sample), path('*.clean.fq.gz')  , emit:reads
    tuple val(sample), path('*.clean.fq.gz')  , emit:clean_reads_salmon
    tuple val(sample), path('*.clean.fq.gz')  , emit:clean_reads_hisat2
    tuple val(sample), path('*.json')         , emit: json
    tuple val(sample), path('*.html')         , emit: html
    tuple val(sample), path('*.log')          , emit: log
    tuple val(sample), path('*.fail.fq.gz'), optional:true, emit: reads_fail

    script:
    if (params.single_end) {
    """
        fastp \\
            --in1 ${reads} \\
            --out1 ${sample}.clean.fq.gz \\
            --thread $task.cpus \\
            --json ${sample}.fastp.json \\
            --html ${sample}.fastp.html \\
            --failed_out ${sample}.fail.fq.gz \\
            2> ${sample}.fastp.log
    """

    } else {
    """
        fastp \\
            --in1 ${reads[0]} \\
            --in2 ${reads[1]} \\
            --out1 ${sample}_1.clean.fq.gz \\
            --out2 ${sample}_2.clean.fq.gz \\
            --json ${sample}.fastp.json \\
            --html ${sample}.fastp.html \\
            --unpaired1 ${sample}_1.fail.fq.gz \\
            --unpaired2 ${sample}_2.fail.fq.gz \\
            --thread $task.cpus \\
            --detect_adapter_for_pe \\
            2> ${sample}.fastp.log
    """

    }
}
/*
--------------------------------------------------------------------------------
Define a fastqc for clean_reads function for pipeline
--------------------------------------------------------------------------------
*/
process FASTQC_QUALITY_CHECK_FOR_CLEAN_READS {
    tag "$sample"
    publishDir "${params.outdir}/clean_fastqc_report", mode: 'copy'
    input:
    tuple val(sample), path (reads)
    output:
    tuple val(sample), path("*.html"), emit: html
    tuple val(sample), path("*.zip") , emit: zip
    script:
    if (params.single_end) {
        """
        fastqc --threads $task.cpus ${reads}       
        """
    } else {
        """
        fastqc --threads $task.cpus ${reads[0]} ${reads[1]}
        """
}
}




process FASTQC_QUALITY_CHECK_FOR_SORTED_BAM {
	tag "$sample"
    publishDir "${params.outdir}/bam_check", mode: 'copy'
    input:
    tuple val(sample), path (bam)
    output:
    tuple val(sample), path("*.html"), emit: html
    tuple val(sample), path("*.zip") , emit: zip
    script:
    """
    fastqc -t task.cpus -q $bam
    """
}

process BWA_INDEX_BUILD_FOR_GENOME_FASTA {
    tag "$fasta"
    publishDir "${params.outdir}",mode: params.publish_dir_mode,

    //conda (params.enable_conda ? "bioconda::bwa=0.7.17" : null)

    input:
    path fasta
    output:
    path "bwa"  , emit: index

    script:
    """
    mkdir bwa
    bwa index $fasta -p bwa/${fasta.baseName}
    """
}

process SAMTOOLS_FAI_INDEX_FOR_INPUT_GENOME_FASTA {

	input:
	path fasta
	output:
	path ("*.fai"), emit: genome_fai
	script:
	"""
	samtools faidx $fasta
	"""
}

process GATK_CREATE_SEQUENCE_DICTIONARY_FOR_INPUT_GENOME_FASTA{

    input:
    path fasta
    output:
    path ("*.dict"), emit: genome_dict
    script:
    """
    gatk CreateSequenceDictionary -R $fasta
    """
}


process BWA_MAPPING_FOR_CLEAN_READS_RESULTED_BY_FASTP {
    tag "$sample"
    
    //conda (params.enable_conda ? "bioconda::bwa=0.7.17 bioconda::samtools=1.10" : null)

    input:
    tuple val(sample), path (reads)
    path  index

    output:
    tuple val(sample), path("*.bam"), emit: bam

    script:

    def read_group = "-R \"@RG\\tID:lane1\\tPL:illumina\\tLB:library\\tSM:$sample\""
    """
    INDEX=`find -L ./ -name "*.amb" | sed 's/.amb//'`
    bwa mem \\
        $read_group \\
        -t $task.cpus \\
        \$INDEX \\
        ${reads[0]} \\
        ${reads[1]} \\
        | samtools view -F 4 -F 8 -F 256 -@ $task.cpus -bhS -o ${sample}.bam

    """
}
/*
--------------------------------------------------------------------------------
Define a bam sort function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_SORTING_BAM_FOR_BWA_UNSORTED_BAM{
    tag "$sample"
    input:
    tuple val(sample), path (bam)
    output:
    tuple val(sample), path("*.sorted.bam") , emit: sorted_bam

    script:
    """
    samtools sort -@ $task.cpus -o ${sample}.sorted.bam -T $sample $bam
    """
}
/*
--------------------------------------------------------------------------------
Define a bam index function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_INDEX_FOR_BWA_MAPPED_BAM {
    tag "$sample"
    publishDir "${params.outdir}/bam_report/idx_statistics",mode: 'copy'

    input:
    tuple val(sample), path (bam)

    output:
    tuple val(sample), path("*.idxstats"), emit: idxstats

    script:

    """
    samtools index $bam
    samtools idxstats $bam > ${bam}.idxstats

    """
}
/*
--------------------------------------------------------------------------------
Define a bam stat function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_STAT_FOR_BWA_MAPPED_BAM{
    tag "$sample"
    publishDir "${params.outdir}/bam_report/statistics",mode: 'copy'

    input:
    tuple val(sample), path (bam)

    output:
    tuple val(sample), path("*.stats"), emit: stats

    script:

    """
    samtools stats $bam > ${bam}.stats

    """
}
/*
--------------------------------------------------------------------------------
Define a bam flagstat function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_FLAGSTAT_FOR_BWA_MAPPED_BAM{
    tag "$sample"
    publishDir "${params.outdir}/bam_report/flag_statistics",mode: 'copy'

    input:
    tuple val(sample), path (bam)

    output:

    tuple val(sample), path("*.flagstat"), emit: flagstat

    script:

    """
    samtools flagstat $bam > ${bam}.flagstat

    """
}

process GATK_MARKDUPLICATES_FOR_BWA_SAMTOOLS_SORTED_BAM{
	tag "$sample"
	publishDir "$params.outdir/MarkDuplicates/metric", pattern: '*.metrics'
	input:
	tuple val(sample), path (bam)
	output:
	tuple val(sample), path ("*.sorted.MarkDuplicates.bam") , emit: markdup_bam
	tuple val(sample), path ("*.bai") , 					  emit: bai
	tuple val(sample), path ("*.sorted.bam.metrics") , 		  emit: metrics

	script:
	"""
	gatk \\
		--java-options \\
		"-Xmx10G -Djava.io.tmpdir=./" \\
		MarkDuplicates \\
		-I $bam \\
		-O ${sample}.sorted.MarkDuplicates.bam \\
		-M ${sample}.sorted.bam.metrics > ${sample}.mark
	samtools index ${sample}.sorted.MarkDuplicates.bam
	"""
}

process GATK_BASERECALIBRATOR_FOR_GATK_MARKDUPLICATES_BAM{
	tag "$sample"
	publishDir "$params.outdir/BaseRecalibrator/table", pattern: '*.table'
	input:
	tuple val(sample), path (bam)
	path fai
    path dict
	path genome
	path dbsnp
	path indel1
	path indel2
    path dbsnp_index
    path indel1_index
    path indel2_index
	output:
	tuple val(sample), path ("*.recal.data.table") , emit: bqsr_table

	script:
	"""
	gatk \\
		--java-options \\
		"-Xmx10G -Djava.io.tmpdir=./" \\
		BaseRecalibrator \\
		-R $genome \\
		-I ${sample}.sorted.MarkDuplicates.bam \\
		--known-sites $indel1 \\
		--known-sites $indel2 \\
		--known-sites $dbsnp \\
		-O ${sample}.recal.data.table
	"""
}

process GATK_APPLYBQSR_FOR_MARKDUPLICATES_BAM_WITH_BASERECALIBRATOR_TABLE{
	tag "$sample"
	input:
	tuple val(sample), path (bam)
	path fai
    path dict
	path genome
	tuple val(sample),path (recal_table)

	output:
	tuple val(sample), path ("*.sorted.MarkDuplicates.BQSR.bam") , emit: bqsr_bam
	script:
	"""
	gatk \\
		--java-options \\
		"-Xmx10G -Djava.io.tmpdir=./" \\
		ApplyBQSR \\
		-R $genome \\
		-I $bam \\
		-bqsr $recal_table \\
		-O ${sample}.sorted.MarkDuplicates.BQSR.bam

	"""
}

process GATK_HAPLOTYPECALLER_FOR_APPLIED_BQSR_QC_BAM  {
	tag "$sample"
	publishDir "${params.outdir}/gatk_vcf/gatk_gvcf", mode: params.publish_dir_mode
	input:
	tuple val(sample), path (bam)
	path fai
    path dict
	path genome
	path dbsnp
	path dbsnp_index
	output:
	tuple val(sample), path ("*.gvcf") , emit: gvcf
	script:
	"""
	gatk \\
		--java-options \\
		"-Xmx12G -Djava.io.tmpdir=./" \\
		HaplotypeCaller \\
		-R $genome \\
		--emit-ref-confidence GVCF \\
		-I $bam \\
		-D $dbsnp \\
		-O ${sample}.gvcf
	"""
}


process COMBINE_GVCF_FILE_RESULTED_BY_GATK_HAPLOTYPECALLER{
    tag "$sample"
	publishDir "${params.outdir}/gatk_vcf/gatk_gvcf/merged_gvcf", mode: params.publish_dir_mode
	input:
    //tuple val(sample), path(gvcfs)
	path fai
    path dict
	path genome
	path ('gvcf_path/*')
	output:
	path ("GATK_combined_bqsr.gvcf") , emit: combined_gvcf

	script:
    /*def input = ""
    for (gvcf in gvcfs) {
        input += " --variant ${gvcf}"
    }   */

	"""
    ls -lhrt gvcf_path/* |awk '{print \$11}' > gvcf.list

	gatk \\
		--java-options \\
		"-Xmx8G -Djava.io.tmpdir=./" \\
		CombineGVCFs \\
		-R $genome \\
		--variant gvcf.list \\
		-O GATK_combined_bqsr.gvcf
	"""
} 

process GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES{
	
	publishDir "${params.outdir}/gatk_vcf", mode: params.publish_dir_mode
	input:
	path gvcf
	path fai
  	path dict
	path genome
  /*path dbsnp
    path indel
    path hapmap
    path omni
    path phase
    path dbsnp_index
    path indel_index
    path hapmap_index
    path omni_index
    path phase_index*/

	output:
	path ("GATK_combined_bqsr.vcf") ,  emit: vcf
    path ("merged.VQSR.snps.vcf") ,   emit: snp
    path ("merged.VQSR.indel.vcf") ,  emit: indel
	script:
	"""
	gatk \\
    		GenotypeGVCFs \\
    		-R $genome \\
    		-V $gvcf \\
    		-O GATK_combined_bqsr.vcf
  """
/*
    gatk \\
            --java-options \\
            "-Xmx8G -Djava.io.tmpdir=./" \\
            VariantRecalibrator \\
            -R $genome \\
            -V GATK_combined_bqsr.vcf \\
            -resource:hapmap,known=false,training=true,truth=true,prior=15.0 $hapmap \\
            -resource:omini,known=false,training=true,truth=false,prior=12.0 $omni \\
            -resource:1000G,known=false,training=true,truth=false,prior=10.0 $phase \\
            -resource:dbsnp,known=true,training=false,truth=false,prior=6.0 $dbsnp \\
            --tranches-file merged.snps.tranches \\
            --rscript-file merged.snps.plots.R \\
            -an QD \\
            -an MQ \\
            -an MQRankSum \\
            -an ReadPosRankSum \\
            -an FS \\
            -an SOR \\
            -an DP \\
            -mode SNP \\
            -O merged.snps.recal 
        
    gatk \\
            ApplyVQSR \\
            -R $genome \\
            -V GATK_combined_bqsr.vcf \\
            --tranches-file merged.snps.tranches \\
            -recal-file merged.snps.recal \\
            -mode SNP \\
            -O merged.VQSR.snps.vcf 
        
    gatk \\
            --java-options \\
            "-Xmx8G -Djava.io.tmpdir=./" \\
            VariantRecalibrator \\
            -R $genome \\
            -V GATK_combined_bqsr.vcf \\
            -resource:indel,known=false,training=true,truth=true,prior=15.0 $indel \\
            -resource:dbsnp,known=true,training=false,truth=false,prior=6.0 $dbsnp \\
            --tranches-file merged.indel.tranches \\
            --rscript-file merged.indel.plots.R \\
            -an QD \\
            -an MQ \\
            -an MQRankSum \\
            -an ReadPosRankSum \\
            -an FS \\
            -an SOR \\
            -an DP \\
            -mode INDEL \\
            -O merged.indel.recal 
    
    gatk \\
            ApplyVQSR \\
            -R $genome \\
            -V GATK_combined_bqsr.vcf \\
            --tranches-file merged.indel.tranches \\
            -recal-file merged.indel.recal  \\
            -mode INDEL \\
            -O merged.VQSR.indel.vcf
	"""

*/	
}

process GATK_SELECT_SNP_VARIANTS_FOR_MERGED_RAW_VCF{
  label 'gatk'
  publishDir "${params.outdir}/gatk_vcf/snp/raw", mode: params.publish_dir_mode
  input:
  path vcf
  output:
  path ("snp.raw.vcf") ,  emit: vcf

  script:
  """
  gatk SelectVariants \\
             -select-type SNP \\
             -V $vcf \\
             -O snp.raw.vcf

  """
} 

process GATK_SELECT_INDEL_VARIANTS_FOR_MERGED_RAW_VCF{
  label 'gatk'
  publishDir "${params.outdir}/gatk_vcf/indel/raw", mode: params.publish_dir_mode
  input:
  path vcf
  output:
  path ("indel.raw.vcf") ,  emit: vcf

  script:
  """
  gatk SelectVariants \\
             -select-type INDEL \\
             -V $vcf \\
             -O indel.raw.vcf

  """

} 

process GATK_SNP_VARIANTS_FILTRATION_FOR_RAW_SNP_VCF{
  label 'gatk'
  publishDir "${params.outdir}/gatk_vcf/snp/clean", mode: params.publish_dir_mode
  input:
  path vcf
  output:
  path ("snp.clean.vcf") ,  emit: vcf
  script:
  """
  gatk \\
          VariantFiltration \\
          -V $vcf \\
          --filter-expression "QD < 2.0 || MQ < 40.0 || FS > 60.0 || SOR > 3.0 || MQRankSum < -12.5 || ReadPosRankSum < -8.0" \\
          --filter-name "PASS" \\
          -O snp.clean.vcf
  """
} 

process GATK_INDEL_VARIANTS_FILTRATION_FOR_RAW_INDEL_VCF{
  label 'gatk'
  publishDir "${params.outdir}/gatk_vcf/indel/clean", mode: params.publish_dir_mode
  input:
  path vcf
  output:
  path ("indel.clean.vcf") ,  emit: vcf
  script:
  """
  gatk \\
          VariantFiltration \\
          -V $vcf \\
          --filter-expression "QD < 2.0 || FS > 200.0 || SOR > 10.0 || MQRankSum < -12.5 || ReadPosRankSum < -8.0"  \\
          --filter-name "PASS" \\
          -O indel.clean.vcf
  """
} 

process ANNOVAR_FORMAT_CONVERT_FOR_RAW_SNP_VARIANTS{

  publishDir "${params.outdir}/annovar/input/raw_snp", mode: params.publish_dir_mode
  input:
  path vcf
  output:
  path ("snp.avinput") ,  emit: avinput
  script:
  """
  convert2annovar.pl -format vcf4 $vcf >snp.avinput
  """ 
}

process ANNOVAR_FORMAT_CONVERT_FOR_RAW_INDEL_VARIANTS{
  publishDir "${params.outdir}/annovar/input/raw_indel", mode: params.publish_dir_mode
  input:
  path vcf
  output:
  path ("indel.avinput") ,  emit: avinput
  script:
  """
  convert2annovar.pl -format vcf4 $vcf >indel.avinput
  """
}

process ANNOVAR_FORMAT_CONVERT_FOR_CLEAN_SNP_VARIANTS{
  publishDir "${params.outdir}/annovar/input/clean_snp", mode: params.publish_dir_mode
  input:
  path vcf
  output:
  path ("snp.avinput") ,  emit: avinput
  script:
  """
  convert2annovar.pl -format vcf4 $vcf >snp.avinput
  """
}

process ANNOVAR_FORMAT_CONVERT_FOR_CLEAN_INDEL_VARIANTS{
  publishDir "${params.outdir}/annovar/input/clean_indel", mode: params.publish_dir_mode
  input:
  path vcf
  output:
  path ("indel.avinput") ,  emit: avinput
  script:
  """
  convert2annovar.pl -format vcf4 $vcf >indel.avinput
  """
}

process ANNOVAR_VARIANTS_ANNOTATION_FOR_RAW_SNP_VARIANTS{
  publishDir "${params.outdir}/annovar/results/raw_snp", mode: params.publish_dir_mode
  input:
  path avinput
  output:
  path ("snp_annotation.hg38_multianno.csv") ,  emit: avoutput

  script:
  """
  table_annovar.pl $avinput ${params.annovar_db} -buildver hg38 -out snp_annotation -remove -protocol refGene,cytoBand,esp6500siv2_all -operation g,r,f -nastring . -csvout

  """
}
process ANNOVAR_VARIANTS_ANNOTATION_FOR_RAW_INDEL_VARIANTS{
  publishDir "${params.outdir}/annovar/results/raw_indel", mode: params.publish_dir_mode
  input:
  path avinput
  output:
  path ("indel_annotation.hg38_multianno.csv") ,  emit: avoutput

  script:
  """
  table_annovar.pl $avinput ${params.annovar_db} -buildver hg38 -out indel_annotation -remove -protocol refGene,cytoBand,esp6500siv2_all -operation g,r,f -nastring . -csvout

  """
}
process ANNOVAR_VARIANTS_ANNOTATION_FOR_CLEAN_SNP_VARIANTS{
  publishDir "${params.outdir}/annovar/results/clean_snp", mode: params.publish_dir_mode
  input:
  path avinput
  output:
  path ("snp_annotation.hg38_multianno.csv") ,  emit: avoutput

  script:
  """
  table_annovar.pl $avinput ${params.annovar_db} -buildver hg38 -out snp_annotation -remove -protocol refGene,cytoBand,esp6500siv2_all -operation g,r,f -nastring . -csvout

  """  
}
process ANNOVAR_VARIANTS_ANNOTATION_FOR_CLEAN_INDEL_VARIANTS{
  publishDir "${params.outdir}/annovar/results/clean_indel", mode: params.publish_dir_mode
  input:
  path avinput
  output:
  path ("indel_annotation.hg38_multianno.csv") ,  emit: avoutput

  script:
  """
  table_annovar.pl $avinput ${params.annovar_db} -buildver hg38 -out indel_annotation -remove -protocol refGene,cytoBand,esp6500siv2_all -operation g,r,f -nastring . -csvout

  """  
}




process TEST_GVCF_LIST {
	publishDir "${params.outdir}/gatk_vcf", mode: params.publish_dir_mode
	input:
	path gvcf_list
	output:
	path ("gvcf_list.txt"), emit: gvcf_list
	script:
	"""
	zcat $gvcf_list > gvcf_list.txt
	"""
}




/*
process GATK_VARIANTRECALIBRATOR_SNP_QUALITY_CONTROL_FOR_COMBINED_VCF_SNP{
	publishDir "${params.outdir}/gatk_vqsr/statistics/snp", mode: params.publish_dir_mode	
	input:
	path (vcf)
	path fai
  path dict
	path genome 
	path dbsnp
	path hapmap
	path omni
	path phase
  path dbsnp_index
  path hapmap_index
  path omni_index
  path phase_index
	output:

	path ("merged.snps.tranches"), emit: tranches
	path ("merged.snps.plots.R"),  emit: plots
	path ("merged.snps.recal"),    emit: recal
	script:
	"""
    gatk \\
    		--java-options \\
    		"-Xmx8G -Djava.io.tmpdir=./" \\
			VariantRecalibrator \\
			-R $genome \\
			-V $vcf \\
			-resource:hapmap,known=false,training=true,truth=true,prior=15.0 $hapmap \\
			-resource:omini,known=false,training=true,truth=false,prior=12.0 $omni \\
			-resource:1000G,known=false,training=true,truth=false,prior=10.0 $phase \\
			-resource:dbsnp,known=true,training=false,truth=false,prior=6.0 $dbsnp \\
			--tranches-file merged.snps.tranches \\
			--rscript-file merged.snps.plots.R \\
			-an QD \\
			-an MQ \\
			-an MQRankSum \\
			-an ReadPosRankSum \\
			-an FS \\
			-an SOR \\
			-an DP \\
			-mode SNP \\
			-O merged.snps.recal 
	"""
}

process GATK_APPLY_VQSR_QUALITY_CONTROL_FOR_COMBINED_RAW_VCF_SNP{
	publishDir "${params.outdir}/gatk_vqsr/snp", mode: params.publish_dir_mode
	input:
	path (vcf) 
	path fai
  path dict
	path genome
	path (tranches)
	path (recal)
	output:
	path ("merged.VQSR.snps.vcf"), emit: vqsr_vcf
	script:
	"""
    gatk \\
    		ApplyVQSR \\
			-R $genome \\
			-V $vcf \\
			--tranches-file $tranches \\
			-recal-file $recal \\
			-mode SNP \\
			-O merged.VQSR.snps.vcf	
	"""
}


process GATK_VARIANTRECALIBRATOR_SNP_QUALITY_CONTROL_FOR_COMBINED_VCF_INDEL{

	publishDir "${params.outdir}/gatk_vqsr/statistics/indel", mode: params.publish_dir_mode	
	input:
	path (vcf)
	path fai
  path dict
	path genome 
	path dbsnp
	path indel
  path dbsnp_index
  path indel_index
	output:

	path ("merged.indel.tranches"), emit: tranches
	path ("merged.indel.plots.R"),  emit: plots
	path ("merged.indel.recal"),    emit: recal
	script:
	"""
    gatk \\
		    --java-options \\
		    "-Xmx8G -Djava.io.tmpdir=./" \\
			VariantRecalibrator \\
			-R $genome \\
			-V $vcf \\
			-resource:indel,known=false,training=true,truth=true,prior=15.0 $indel \\
			-resource:dbsnp,known=true,training=false,truth=false,prior=6.0 $dbsnp \\
			--tranches-file merged.indel.tranches \\
			--rscript-file merged.indel.plots.R \\
			-an QD \\
			-an MQ \\
			-an MQRankSum \\
			-an ReadPosRankSum \\
			-an FS \\
			-an SOR \\
			-an DP \\
			-mode INDEL \\
			-O merged.indel.recal 
	"""
}

process GATK_APPLY_VQSR_QUALITY_CONTROL_FOR_COMBINED_RAW_VCF_INDEL{
	publishDir "${params.outdir}/gatk_vqsr/indel", mode: params.publish_dir_mode
	input:
	path (vcf)
	path fai
  path dict
	path genome
	path (tranches)
	path (recal)
	output:
	path ("merged.VQSR.indel.vcf"), emit: vqsr_vcf
	script:
	"""
    gatk \\
    		ApplyVQSR \\
			-R $genome \\
			-V $vcf \\
			--tranches-file $tranches \\
			-recal-file $recal  \\
			-mode INDEL \\
			-O merged.VQSR.indel.vcf
	"""
}


*/


process MULTIQC_FOR_RAW_READS_FASTQC_RESULTS {
    label 'process_medium'
    publishDir "${params.outdir}/Analysis_Report/raw_reads_fastqc", mode: 'copy'

    input:
    path ('fastqc/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export fastqc/
    """
}

process MULTIQC_FOR_FASTP_READS_FILTER_RESULTS {
    label 'process_medium'
    publishDir "${params.outdir}/Analysis_Report/fastp", mode: 'copy'

    input:
    path ('fastp/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export fastp/
    """
}

process MULTIQC_FOR_CLEAN_READS_FASTQC_RESULTS {
    label 'process_medium'
    publishDir "${params.outdir}/Analysis_Report/raw_reads_fastqc", mode: 'copy'

    input:
    path ('fastqc/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export fastqc/
    """
}

process MULTIQC_FOR_SAMTOOLS_STATISTICS_RESULTS {
    label 'process_medium'
    publishDir "${params.outdir}/Analysis_Report/samtools_stat", mode: 'copy'

    input:
    path ('samtools_stat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_stat/
    """
}

process MULTIQC_FOR_SAMTOOLS_FLAG_STATISTICS_RESULTS {
    label 'process_medium'
    publishDir "${params.outdir}/Analysis_Report/samtools_flagstat", mode: 'copy'

    input:
    path ('samtools_flagstat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_flagstat/
    """
}

process MULTIQC_FOR_SAMTOOLS_IDX_STATISTICS_RESULTS {
    label 'process_medium'
    publishDir "${params.outdir}/Analysis_Report/samtools_idxstat", mode: 'copy'

    input:
    path ('samtools_idxstat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_idxstat/
    """
}

process MULTIQC_FOR_BAM_MAPPED_AND_SAMTOOLS_SORTED_BAM {
    label 'process_medium'
    publishDir "${params.outdir}/Analysis_Report/bam_mapping", mode: 'copy'

    input:
    path ('bam_mapping/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export bam_mapping/
    """
}

process MULTIQC_FOR_GATK_MARKDUPED_STATISTISC_BAM {
    label 'process_medium'
    publishDir "${params.outdir}/Analysis_Report/GATK_MARKDUP", mode: 'copy'

    input:
    path ('GATK_MARKDUP/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export GATK_MARKDUP/
    """
}

process MULTIQC_FOR_GATK_BQSR_STATISTISC_BAM {
    label 'process_medium'
    publishDir "${params.outdir}/Analysis_Report/GATK_BQSR", mode: 'copy'

    input:
    path ('GATK_BQSR/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export GATK_BQSR/
    """
}

workflow GET_ALL_SOFTWARE_VERSION_FOR_WGS_PIPELINE{

    GET_NEXTFLOW_SOFTWARE_VERSION_FOR_WGS_ANALYSIS (  )
    GET_FASTQC_SOFTWARE_VERSION_FOR_WGS_ANALYSIS (  )
    GET_SAMTOOLS_SOFTWARE_VERSION_FOR_WGS_ANALYSIS (  )
    GET_MULTIQC_SOFTWARE_VERSION_FOR_WGS_ANALYSIS (  )
    GET_BWA_SOFTWARE_VERSION_FOR_WGS_ANALYSIS (  )
    GET_GATK_SOFTWARE_VERSION_FOR_WGS_ANALYSIS (  )
    GET_FASTP_SOFTWARE_VERSION_FOR_WGS_ANALYSIS (  )

}

/*
--------------------------------------------------------------------------------
Define a fastqc/fastp reads check and filter function for pipeline
--------------------------------------------------------------------------------
*/
workflow FASTQC_QUALITY_CHECK_AND_FASTP_READS_FILTER_FOR_RAW_READS {
    take:
    reads         // channel: [ val(meta), [ reads ] ]
    main:

    raw_fastqc_html    = Channel.empty()
    raw_fastqc_zip     = Channel.empty()

    FASTQC_QUALITY_CHECK_FOR_RAW_READS ( reads ).html.set { raw_fastqc_html }
    raw_fastqc_zip     = FASTQC_QUALITY_CHECK_FOR_RAW_READS.out.zip


    fastp_reads        = reads
    fastp_log          = Channel.empty()
    fastp_json         = Channel.empty()
    fastp_html         = Channel.empty()

  /**  trim_reads = umi_reads
    trim_html  = Channel.empty()
    trim_zip   = Channel.empty()
    trim_log   = Channel.empty()
    trimgalore_version = Channel.empty()*/

    FASTP_READS_FILTER_FOR_RAW_READS ( fastp_reads ).reads.set { clean_reads }
    fastp_html  = FASTP_READS_FILTER_FOR_RAW_READS.out.html
    fastp_json  = FASTP_READS_FILTER_FOR_RAW_READS.out.json
    fastp_log   = FASTP_READS_FILTER_FOR_RAW_READS.out.log


    clean_fastqc_html    = Channel.empty()
    clean_fastqc_zip     = Channel.empty()

    FASTQC_QUALITY_CHECK_FOR_CLEAN_READS ( clean_reads ).html.set { clean_fastqc_html }
    clean_fastqc_zip     = FASTQC_QUALITY_CHECK_FOR_CLEAN_READS.out.zip

    emit:
    clean_reads_ch     = clean_reads
    clean_reads_salmon = clean_reads
    clean_reads_hisat2 = clean_reads
    raw_fastqc_html     //
    clean_fastqc_html   //
    raw_fastqc_zip
    clean_fastqc_zip         // channel: [ val(meta), [ zip ] ]
    fastp_html
    fastp_log          // channel: [ val(meta), [ html ] ]
    fastp_json           // channel: [ val(meta), [ zip ] ]

}

workflow BWA_MAPPING_FOR_CLEAN_READS_AND_SAMTOOLS_SORTSTAT_FOR_MAPPED_READS{

	take:
	genome 
	index
	reads
	main:
	if( !params.bwa_index ){
		BWA_INDEX_BUILD_FOR_GENOME_FASTA ( genome )
		index = BWA_INDEX_BUILD_FOR_GENOME_FASTA.out.index
	}
	
	BWA_MAPPING_FOR_CLEAN_READS_RESULTED_BY_FASTP ( reads, index )
	SAMTOOLS_SORTING_BAM_FOR_BWA_UNSORTED_BAM (BWA_MAPPING_FOR_CLEAN_READS_RESULTED_BY_FASTP.out.bam )
	bam_ch_for_idx = SAMTOOLS_SORTING_BAM_FOR_BWA_UNSORTED_BAM.out.sorted_bam
	bam_ch_for_stat = SAMTOOLS_SORTING_BAM_FOR_BWA_UNSORTED_BAM.out.sorted_bam
	bam_ch_for_flagstat = SAMTOOLS_SORTING_BAM_FOR_BWA_UNSORTED_BAM.out.sorted_bam
	FASTQC_QUALITY_CHECK_FOR_SORTED_BAM ( SAMTOOLS_SORTING_BAM_FOR_BWA_UNSORTED_BAM.out.sorted_bam )
	SAMTOOLS_INDEX_FOR_BWA_MAPPED_BAM ( bam_ch_for_idx )
	SAMTOOLS_STAT_FOR_BWA_MAPPED_BAM ( bam_ch_for_stat )
	SAMTOOLS_FLAGSTAT_FOR_BWA_MAPPED_BAM ( bam_ch_for_flagstat )

	emit:
	bam 	   = SAMTOOLS_SORTING_BAM_FOR_BWA_UNSORTED_BAM.out.sorted_bam
	bam_fastqc = FASTQC_QUALITY_CHECK_FOR_SORTED_BAM.out.zip
	stats      = SAMTOOLS_STAT_FOR_BWA_MAPPED_BAM.out.stats
	idxstat    = SAMTOOLS_INDEX_FOR_BWA_MAPPED_BAM.out.idxstats
	flagstat   = SAMTOOLS_FLAGSTAT_FOR_BWA_MAPPED_BAM.out.flagstat
}

workflow GATK_VARIANTS_CALLING_WORKFLOW_FOR_BWA_MAPPED_AND_SAMTOOLS_SORTED_BAM{

	take:
	bam
	fai
  dict
	genome
	dbsnp
	indel1
	indel2
	hapmap
	omni
	phase
  dbsnp_index
  indel1_index
  indel2_index
  hapmap_index
  omni_index
  phase_index

	main:
	GATK_MARKDUPLICATES_FOR_BWA_SAMTOOLS_SORTED_BAM ( bam )
	bam_ch_for_bqsr = GATK_MARKDUPLICATES_FOR_BWA_SAMTOOLS_SORTED_BAM.out.markdup_bam
	GATK_BASERECALIBRATOR_FOR_GATK_MARKDUPLICATES_BAM ( GATK_MARKDUPLICATES_FOR_BWA_SAMTOOLS_SORTED_BAM.out.markdup_bam, fai, dict, genome, dbsnp, indel1, indel2,
                                                        dbsnp_index, indel1_index, indel2_index  )
	GATK_APPLYBQSR_FOR_MARKDUPLICATES_BAM_WITH_BASERECALIBRATOR_TABLE ( bam_ch_for_bqsr, fai, dict, genome, GATK_BASERECALIBRATOR_FOR_GATK_MARKDUPLICATES_BAM.out.bqsr_table )
	GATK_HAPLOTYPECALLER_FOR_APPLIED_BQSR_QC_BAM ( GATK_APPLYBQSR_FOR_MARKDUPLICATES_BAM_WITH_BASERECALIBRATOR_TABLE.out.bqsr_bam, fai, dict, genome, dbsnp, dbsnp_index )
    //GATK_HAPLOTYPECALLER_FOR_APPLIED_BQSR_QC_BAM.out.gvcf.collectFile(name: 'input_list.txt', newLine: true)
	//															.view { it.text }
    //                                                            .set { GvcfFileList }
	//GATK_HAPLOTYPECALLER_FOR_APPLIED_BQSR_QC_BAM.out.gvcf.collect{it[1]}



    //TEST_GVCF_LIST ( GvcfFileList )
	COMBINE_GVCF_FILE_RESULTED_BY_GATK_HAPLOTYPECALLER ( fai, dict, genome, GATK_HAPLOTYPECALLER_FOR_APPLIED_BQSR_QC_BAM.out.gvcf.collect{it[1]} ) 

  GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES ( COMBINE_GVCF_FILE_RESULTED_BY_GATK_HAPLOTYPECALLER.out.combined_gvcf, fai, dict, genome 
    //  dbsnp, indel2, hapmap, omni, phase, dbsnp_index, indel2_index, hapmap_index, omni_index, phase_index
    )
  vcf_for_snp_select    = GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES.out.vcf
  vcf_for_indel_select  = GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES.out.vcf

  GATK_SELECT_SNP_VARIANTS_FOR_MERGED_RAW_VCF ( vcf_for_snp_select )
  GATK_SELECT_INDEL_VARIANTS_FOR_MERGED_RAW_VCF ( vcf_for_indel_select )
  raw_snp_for_av        = GATK_SELECT_SNP_VARIANTS_FOR_MERGED_RAW_VCF.out.vcf
  raw_indel_for_av      = GATK_SELECT_INDEL_VARIANTS_FOR_MERGED_RAW_VCF.out.vcf
  GATK_SNP_VARIANTS_FILTRATION_FOR_RAW_SNP_VCF ( GATK_SELECT_SNP_VARIANTS_FOR_MERGED_RAW_VCF.out.vcf )
  GATK_INDEL_VARIANTS_FILTRATION_FOR_RAW_INDEL_VCF ( GATK_SELECT_INDEL_VARIANTS_FOR_MERGED_RAW_VCF.out.vcf )
  ANNOVAR_FORMAT_CONVERT_FOR_RAW_SNP_VARIANTS ( raw_snp_for_av )
  ANNOVAR_FORMAT_CONVERT_FOR_RAW_INDEL_VARIANTS ( raw_indel_for_av )
  ANNOVAR_FORMAT_CONVERT_FOR_CLEAN_SNP_VARIANTS ( GATK_SNP_VARIANTS_FILTRATION_FOR_RAW_SNP_VCF.out.vcf )
  ANNOVAR_FORMAT_CONVERT_FOR_CLEAN_INDEL_VARIANTS ( GATK_INDEL_VARIANTS_FILTRATION_FOR_RAW_INDEL_VCF.out.vcf )
  ANNOVAR_VARIANTS_ANNOTATION_FOR_RAW_SNP_VARIANTS ( ANNOVAR_FORMAT_CONVERT_FOR_RAW_SNP_VARIANTS.out.avinput )
  ANNOVAR_VARIANTS_ANNOTATION_FOR_RAW_INDEL_VARIANTS ( ANNOVAR_FORMAT_CONVERT_FOR_RAW_INDEL_VARIANTS.out.avinput )
  ANNOVAR_VARIANTS_ANNOTATION_FOR_CLEAN_SNP_VARIANTS ( ANNOVAR_FORMAT_CONVERT_FOR_CLEAN_SNP_VARIANTS.out.avinput )
  ANNOVAR_VARIANTS_ANNOTATION_FOR_CLEAN_INDEL_VARIANTS ( ANNOVAR_FORMAT_CONVERT_FOR_CLEAN_INDEL_VARIANTS.out.avinput )
  /*  
  vcf_ch_vqsr_snp_call    = GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES.out.vcf
  vcf_ch_vqsr_snp_apply   = GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES.out.vcf
  vcf_ch_vqsr_indel_call  = GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES.out.vcf
  vcf_ch_vqsr_indel_apply = GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES.out.vcf 
    
  GATK_VARIANTRECALIBRATOR_SNP_QUALITY_CONTROL_FOR_COMBINED_VCF_SNP ( GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES.out.vcf, fai, dict, genome, dbsnp, hapmap, omni, phase, 
                                                                        dbsnp_index, hapmap_index, omni_index, phase_index )
	GATK_APPLY_VQSR_QUALITY_CONTROL_FOR_COMBINED_RAW_VCF_SNP ( vcf_ch_vqsr_snp_apply, fai, dict, genome, 
								GATK_VARIANTRECALIBRATOR_SNP_QUALITY_CONTROL_FOR_COMBINED_VCF_SNP.out.tranches, 
								GATK_VARIANTRECALIBRATOR_SNP_QUALITY_CONTROL_FOR_COMBINED_VCF_SNP.out.recal )
	GATK_VARIANTRECALIBRATOR_SNP_QUALITY_CONTROL_FOR_COMBINED_VCF_INDEL ( vcf_ch_vqsr_indel_call, fai, dict, genome, dbsnp, indel2, dbsnp_index, indel2_index )
	GATK_APPLY_VQSR_QUALITY_CONTROL_FOR_COMBINED_RAW_VCF_INDEL ( vcf_ch_vqsr_indel_apply, fai, dict, genome, 
								GATK_VARIANTRECALIBRATOR_SNP_QUALITY_CONTROL_FOR_COMBINED_VCF_INDEL.out.tranches, 
								GATK_VARIANTRECALIBRATOR_SNP_QUALITY_CONTROL_FOR_COMBINED_VCF_INDEL.out.recal )  */

	emit:
	markdup_metrics   =  GATK_MARKDUPLICATES_FOR_BWA_SAMTOOLS_SORTED_BAM.out.metrics
	bqsr_table		    =	 GATK_BASERECALIBRATOR_FOR_GATK_MARKDUPLICATES_BAM.out.bqsr_table
	sample_gvcf       =  GATK_HAPLOTYPECALLER_FOR_APPLIED_BQSR_QC_BAM.out.gvcf
	combined_gvcf     =  COMBINE_GVCF_FILE_RESULTED_BY_GATK_HAPLOTYPECALLER.out.combined_gvcf
	combined_vcf      =  GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES.out.vcf
	//vqsr_snp          =  GATK_APPLY_VQSR_QUALITY_CONTROL_FOR_COMBINED_RAW_VCF_SNP.out.vqsr_vcf
	//vqsr_indel        =  GATK_APPLY_VQSR_QUALITY_CONTROL_FOR_COMBINED_RAW_VCF_INDEL.out.vqsr_vcf
  //  snp               = GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES.out.snp
  //  indel             = GATK_GENOTYPEGVCFS_FOR_HAPLOTYPECALLER_RESULTED_GVCF_FILES.out.indel
  combined_raw_snp         = GATK_SELECT_SNP_VARIANTS_FOR_MERGED_RAW_VCF.out.vcf
  combined_raw_indel       = GATK_SELECT_INDEL_VARIANTS_FOR_MERGED_RAW_VCF.out.vcf
  combined_clean_snp       = GATK_SNP_VARIANTS_FILTRATION_FOR_RAW_SNP_VCF.out.vcf
  combined_clean_indel     = GATK_INDEL_VARIANTS_FILTRATION_FOR_RAW_INDEL_VCF.out.vcf
  annotation_raw_snp       = ANNOVAR_VARIANTS_ANNOTATION_FOR_RAW_SNP_VARIANTS.out.avoutput
  annotation_raw_indel     = ANNOVAR_VARIANTS_ANNOTATION_FOR_RAW_INDEL_VARIANTS.out.avoutput
  annotation_clean_snp     = ANNOVAR_VARIANTS_ANNOTATION_FOR_CLEAN_SNP_VARIANTS.out.avoutput
  annotation_clean_indel   = ANNOVAR_VARIANTS_ANNOTATION_FOR_CLEAN_INDEL_VARIANTS.out.avoutput
}

workflow MULTIQC_REPORT_FOR_ALL_ANALYSIS_RESULTS {

    take:
    raw_reads_fastqc_zip
    fastq_results 
    clean_reads_fastqc_zip
    samtools_stat_results
    samtools_flagstat_results
    samtools_idxstat_results
    bam_fastqc
    markdup_metrics
    bqsr_table


    main:
    MULTIQC_FOR_RAW_READS_FASTQC_RESULTS ( raw_reads_fastqc_zip )
    MULTIQC_FOR_FASTP_READS_FILTER_RESULTS ( fastq_results )
    MULTIQC_FOR_CLEAN_READS_FASTQC_RESULTS ( clean_reads_fastqc_zip )
    MULTIQC_FOR_SAMTOOLS_STATISTICS_RESULTS ( samtools_stat_results )
    MULTIQC_FOR_SAMTOOLS_FLAG_STATISTICS_RESULTS ( samtools_flagstat_results )
    MULTIQC_FOR_SAMTOOLS_IDX_STATISTICS_RESULTS ( samtools_idxstat_results )
    MULTIQC_FOR_BAM_MAPPED_AND_SAMTOOLS_SORTED_BAM ( bam_fastqc )
    MULTIQC_FOR_GATK_MARKDUPED_STATISTISC_BAM ( markdup_metrics )
    MULTIQC_FOR_GATK_BQSR_STATISTISC_BAM ( bqsr_table )

}
/*
--------------------------------------------------------------------------------
THIS IS THE START OF PIPELINE
--------------------------------------------------------------------------------
*/
workflow {

    GET_ALL_SOFTWARE_VERSION_FOR_WGS_PIPELINE (  )

	FASTQC_QUALITY_CHECK_AND_FASTP_READS_FILTER_FOR_RAW_READS ( raw_reads )
	BWA_MAPPING_FOR_CLEAN_READS_AND_SAMTOOLS_SORTSTAT_FOR_MAPPED_READS ( genome_fasta, params.bwa_index, FASTQC_QUALITY_CHECK_AND_FASTP_READS_FILTER_FOR_RAW_READS.out.clean_reads_ch )
	
	SAMTOOLS_FAI_INDEX_FOR_INPUT_GENOME_FASTA ( genome_fasta )
	fai = SAMTOOLS_FAI_INDEX_FOR_INPUT_GENOME_FASTA.out.genome_fai

  GATK_CREATE_SEQUENCE_DICTIONARY_FOR_INPUT_GENOME_FASTA ( genome_fasta )
  dict = GATK_CREATE_SEQUENCE_DICTIONARY_FOR_INPUT_GENOME_FASTA.out.genome_dict
	
	GATK_VARIANTS_CALLING_WORKFLOW_FOR_BWA_MAPPED_AND_SAMTOOLS_SORTED_BAM ( BWA_MAPPING_FOR_CLEAN_READS_AND_SAMTOOLS_SORTSTAT_FOR_MAPPED_READS.out.bam,
																			dict, fai, genome_fasta, dbsnp, indel1, indel2, hapmap, omni, phase,
                                      dbsnp_index, indel1_index, indel2_index, hapmap_index, omni_index, phase_index )

  MULTIQC_REPORT_FOR_ALL_ANALYSIS_RESULTS ( FASTQC_QUALITY_CHECK_AND_FASTP_READS_FILTER_FOR_RAW_READS.out.raw_fastqc_zip.collect{it[1]},
        											              FASTQC_QUALITY_CHECK_AND_FASTP_READS_FILTER_FOR_RAW_READS.out.fastp_json.collect{it[1]},
        											              FASTQC_QUALITY_CHECK_AND_FASTP_READS_FILTER_FOR_RAW_READS.out.clean_fastqc_zip.collect{it[1]}, 
        											              BWA_MAPPING_FOR_CLEAN_READS_AND_SAMTOOLS_SORTSTAT_FOR_MAPPED_READS.out.stats.collect{it[1]}, 
        											              BWA_MAPPING_FOR_CLEAN_READS_AND_SAMTOOLS_SORTSTAT_FOR_MAPPED_READS.out.flagstat.collect{it[1]}, 
        											              BWA_MAPPING_FOR_CLEAN_READS_AND_SAMTOOLS_SORTSTAT_FOR_MAPPED_READS.out.idxstat.collect{it[1]}, 
        											              BWA_MAPPING_FOR_CLEAN_READS_AND_SAMTOOLS_SORTSTAT_FOR_MAPPED_READS.out.bam_fastqc.collect{it[1]}, 
        											              GATK_VARIANTS_CALLING_WORKFLOW_FOR_BWA_MAPPED_AND_SAMTOOLS_SORTED_BAM.out.markdup_metrics.collect{it[1]}, 
        											              GATK_VARIANTS_CALLING_WORKFLOW_FOR_BWA_MAPPED_AND_SAMTOOLS_SORTED_BAM.out.bqsr_table.collect{it[1]}
        											  ) 

}

/*
====================================================
====================================================
*/



def nfcoreHeader() {
    // Log colors ANSI codes
    c_black = params.monochrome_logs ? '' : "\033[0;30m";
    c_blue = params.monochrome_logs ? '' : "\033[0;34m";
    c_cyan = params.monochrome_logs ? '' : "\033[0;36m";
    c_dim = params.monochrome_logs ? '' : "\033[2m";
    c_green = params.monochrome_logs ? '' : "\033[0;32m";
    c_purple = params.monochrome_logs ? '' : "\033[0;35m";
    c_reset = params.monochrome_logs ? '' : "\033[0m";
    c_white = params.monochrome_logs ? '' : "\033[0;37m";
    c_yellow = params.monochrome_logs ? '' : "\033[0;33m";

    return """    -${c_dim}--------------------------------------------------${c_reset}-
                                            ${c_green},--.${c_black}/${c_green},-.${c_reset}
    ${c_blue}        ___     __   __   __   ___     ${c_green}/,-._.--~\'${c_reset}
    ${c_blue}  |\\ | |__  __ /  ` /  \\ |__) |__         ${c_yellow}}  {${c_reset}
    ${c_blue}  | \\| |       \\__, \\__/ |  \\ |___     ${c_green}\\`-._,-`-,${c_reset}
                                            ${c_green}`._,._,\'${c_reset}
    ${c_purple}  nf-core/rnaseq_pipeline/@zhangdongqin2@126.com v${workflow.manifest.version}${c_reset}
    -${c_dim}--------------------------------------------------${c_reset}-
    """.stripIndent()
}